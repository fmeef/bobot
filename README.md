# Dijkstra: a modular telegram bot written in rust

Dijkstra is a modular telegram bot framework focused on group administration
with features geared towards performance and manageability at scale. Dijkstra is built using
[botapi-rs](https://github.com/fmeef/botapi-rs), an companion project providing an 
autogenerated telegram api wrapper  

An example instance is deployed at [https://t.me/SirDijkstraBot](https://t.me/SirDijkstraBot)

### Deploying
The following steps will deploy an instance of Dijkstra using long polling. This is suitable for
testing, but for production deployments webhooks should be configured

1. message [@BotFather](https://t.me/BotFather) and generate an new bot. Make sure to disable "Group Privacy" in the
bot settings module.  
2. Copy your bot token and save for later.  
3. Copy `config/config.toml.example` to `config/config.toml` and edit it. Replace the bot_token field
with the token you copied.   
4. Change the postgresql password if desired. Also edit docker-compose.yml and change `POSTGRES_PASSWORD`  
5. run `docker-compose build`  
6. run `docker-compose up`  

To enable webooks, set `enable_webhook = true` in your config.toml, set the `wehbook_url` parameter
to your domain name, then setup your favorite https loadbalancer using the configuration in this 
[guide](https://core.telegram.org/bots/webhooks). Add a reverse proxy pointing to the bot's local ip
on port 8080 by default. An example config for nginx is:


```nginx
server {
  server_name bot.example.com;
  ignore_invalid_headers off;
  listen 8443 ssl http2; # managed by Certbot
  ssl_certificate /etc/letsencrypt/live/bot.example.com/fullchain.pem; # managed by Certbot
  ssl_certificate_key /etc/letsencrypt/live/bot.example.com/privkey.pem; # managed by Certbot
  ssl on;
  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
	ssl_ciphers 'EECDH+AESGCM:EECDH+AES256';

	ssl_ecdh_curve secp384r1;
	ssl_prefer_server_ciphers on;

	ssl_session_cache shared:SSL:10m;
	ssl_session_timeout 1d;

	ssl_stapling on;
	ssl_stapling_verify on;

	add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload";
    location / {
		proxy_set_header Host $http_host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass          http://127.0.0.1:8080;
	}

}
```

## Design goals
Dijkstra is designed from the ground up for scalability, modularity, and security

### Scalability
Dijkstra is built to scale, with focuses on minimizing database IO bottlenecks, aggressive
caching of telegram API calls, and an efficient workflow for rapidly responding to telegram
error codes and api changes.  

- Whenever possible a redis cache is used over the main database to reduce disk IO
bandwidth usage. The redis caching layer is designed to operate with or without persistence, falling
back to raw postgres queries cached in redis for critical persistent data.  
- Runtime error reporting logs to an optional prometheus instance for realtime monitoring of bottlenecks,
api errors, and potential telegram rate limiting.  
- Use of an autogenerated bot api wrapper allows for minimal downtime during telegram api changes

### Modularity
The bot framework itself provides a core library meant to be used by
swappable "modules" providing self-contained features. Modules are self-contained rust source files
bringing their own metadata, command helps, database migrations, and implementation. This allows
modules to be easily shared as single files, and installed by non-technical users.  
Modules are autoconfigured by a build script without the need to edit rust source files with a
`mod somemodule;`, making their usage more familiar to users of python based bot frameworks.

### Security
Transparent DoS mitigation is baked into the core API. Individual chats are ratelimited clientside
 to prevent large volumes of messages from triggering a telegram serverside ratelimit. 
Untrusted regex patterns are not accepted to mitigate the risk of
[ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS).
Instead of regex, pattern matching is achieved by a custom globbing engine.  
Dijkstra also uses granular permissions for restricting bot features behind familliar telegram admin
permissions
