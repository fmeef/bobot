mod fbans ; mod rules ; mod locks ; mod bans ; mod notes ; mod import_export ; mod approvals ; mod buttontest ; mod sticker ; mod misc ; mod gbans ; mod filters ; mod welcome ; mod blocklists ; mod language ; mod reports ; mod warns ; mod captcha ; mod admin ; use crate :: util :: string :: Speak ; pub fn get_migrations () -> :: std :: vec :: Vec < :: std :: boxed :: Box < dyn :: sea_orm_migration :: prelude :: MigrationTrait >> { let mut v = :: std :: vec :: Vec :: < :: std :: boxed :: Box < dyn :: sea_orm_migration :: prelude :: MigrationTrait >> :: new () ; if let Some (ref md) = fbans :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = rules :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = locks :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = bans :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = notes :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = import_export :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = approvals :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = buttontest :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = sticker :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = misc :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = gbans :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = filters :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = welcome :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = blocklists :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = language :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = reports :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = warns :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = captcha :: METADATA . state { v . append (& mut md . get_migrations ()) ; } if let Some (ref md) = admin :: METADATA . state { v . append (& mut md . get_migrations ()) ; } v } pub async fn all_export (chat : i64) -> crate :: util :: error :: Result < crate :: tg :: import_export :: RoseExport > { let mut v = crate :: tg :: import_export :: RoseExport :: new () ; if let Some (ref md) = fbans :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = rules :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = locks :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = bans :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = notes :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = import_export :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = approvals :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = buttontest :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = sticker :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = misc :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = gbans :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = filters :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = welcome :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = blocklists :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = language :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = reports :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = warns :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = captcha :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } if let Some (ref md) = admin :: METADATA . state { if let (Some (export) , Some (name)) = (md . export (chat) . await ? , md . supports_export ()) { v . data . insert (name . to_owned () , export) ; } } Ok (v) } pub async fn all_import (chat : i64 , json : & str) -> crate :: util :: error :: Result < crate :: tg :: import_export :: RoseExport > { let mut v : crate :: tg :: import_export :: RoseExport = :: serde_json :: from_str (json) ? ; if let Some (ref md) = fbans :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = rules :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = locks :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = bans :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = notes :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = import_export :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = approvals :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = buttontest :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = sticker :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = misc :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = gbans :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = filters :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = welcome :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = blocklists :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = language :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = reports :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = warns :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = captcha :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } if let Some (ref md) = admin :: METADATA . state { if let Some (name) = md . supports_export () { if let Some (value) = v . data . remove (name) { md . import (chat , value) . await ? ; } } } Ok (v) } pub fn get_metadata () -> :: std :: vec :: Vec < crate :: metadata :: Metadata > { vec ! [(* fbans :: METADATA) . clone () , (* rules :: METADATA) . clone () , (* locks :: METADATA) . clone () , (* bans :: METADATA) . clone () , (* notes :: METADATA) . clone () , (* import_export :: METADATA) . clone () , (* approvals :: METADATA) . clone () , (* buttontest :: METADATA) . clone () , (* sticker :: METADATA) . clone () , (* misc :: METADATA) . clone () , (* gbans :: METADATA) . clone () , (* filters :: METADATA) . clone () , (* welcome :: METADATA) . clone () , (* blocklists :: METADATA) . clone () , (* language :: METADATA) . clone () , (* reports :: METADATA) . clone () , (* warns :: METADATA) . clone () , (* captcha :: METADATA) . clone () , (* admin :: METADATA) . clone () , crate :: metadata :: Metadata { name : "formatting" . to_owned () , description : crate :: metadata :: markdownify (std :: include_str ! ("formatting.mud")) , commands : :: std :: collections :: HashMap :: new () , sections : { let mut v = :: std :: collections :: HashMap :: new () ; v . insert ("Form Filling" . to_owned () , crate :: metadata :: markdownify (std :: include_str ! ("formatting/Form Filling.mud"))) ; v . insert ("Murkdown Formatting" . to_owned () , crate :: metadata :: markdownify (std :: include_str ! ("formatting/Murkdown Formatting.mud"))) ; v } , state : None }] } pub async fn process_updates (update : :: botapi :: gen_types :: UpdateExt , helps : :: std :: sync :: Arc < crate :: tg :: client :: MetadataCollection >) -> crate :: util :: error :: Result < () > { match crate :: tg :: command :: StaticContext :: get_context (update) . await . map (| v | v . yoke ()) { Ok (ctx) => { if let Err (err) = ctx . record_chat_member () . await { log :: error ! ("failed to record chat member {}" , err) ; err . record_stats () ; } ctx . handle_gbans () . await ; if let Err (err) = ctx . greeter_handle_update () . await { log :: error ! ("Failed to greet user {}" , err) ; err . record_stats () ; } if let Err (err) = ctx . handle_pending_action_update () . await { log :: error ! ("failed to handle pending action: {}" , err) ; err . record_stats () ; } let help = if let Some (& crate :: tg :: command :: Cmd { cmd , ref args , message , lang , .. }) = ctx . cmd () { match cmd { "help" => crate :: tg :: client :: show_help (& ctx , message , helps , args . args . first () . map (| a | a . get_text ())) . await , "start" => match args . args . first () . map (| a | a . get_text ()) { Some (v) => { if let (Some ("help") , Some (s)) = (v . get (0 .. 4) , v . get (4 ..)) { let s = if s . len () > 0 { Some (s) } else { None } ; crate :: tg :: client :: show_help (& ctx , message , helps , s) . await ? ; Ok (true) } else { Ok (false) } } None => { log :: info ! ("start with lang {:?}" , lang) ; message . reply (macros :: lang_fmt ! (lang , "startcmd")) . await ? ; Ok (true) } } , _ => Ok (false) , } } else { Ok (false) } ; match help { Ok (false) => { if let Err (err) = fbans :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , fbans :: METADATA . name , err) ; } } } if let Err (err) = rules :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , rules :: METADATA . name , err) ; } } } if let Err (err) = locks :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , locks :: METADATA . name , err) ; } } } if let Err (err) = bans :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , bans :: METADATA . name , err) ; } } } if let Err (err) = notes :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , notes :: METADATA . name , err) ; } } } if let Err (err) = import_export :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , import_export :: METADATA . name , err) ; } } } if let Err (err) = approvals :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , approvals :: METADATA . name , err) ; } } } if let Err (err) = buttontest :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , buttontest :: METADATA . name , err) ; } } } if let Err (err) = sticker :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , sticker :: METADATA . name , err) ; } } } if let Err (err) = misc :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , misc :: METADATA . name , err) ; } } } if let Err (err) = gbans :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , gbans :: METADATA . name , err) ; } } } if let Err (err) = filters :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , filters :: METADATA . name , err) ; } } } if let Err (err) = welcome :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , welcome :: METADATA . name , err) ; } } } if let Err (err) = blocklists :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , blocklists :: METADATA . name , err) ; } } } if let Err (err) = language :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , language :: METADATA . name , err) ; } } } if let Err (err) = reports :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , reports :: METADATA . name , err) ; } } } if let Err (err) = warns :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , warns :: METADATA . name , err) ; } } } if let Err (err) = captcha :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , captcha :: METADATA . name , err) ; } } } if let Err (err) = admin :: update_handler :: handle_update (& ctx) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = ctx . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , admin :: METADATA . name , err) ; } } } } Ok (true) => () , Err (err) => log :: error ! ("failed help {}" , err) } } Err (err) => { log :: error ! ("error when getting context {}" , err) ; err . record_stats () } , } Ok (()) }