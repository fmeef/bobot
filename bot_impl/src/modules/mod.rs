mod rules ; mod locks ; mod bans ; mod notes ; mod approvals ; mod buttontest ; mod sticker ; mod misc ; mod filters ; mod welcome ; mod blocklists ; mod language ; mod reports ; mod warns ; mod captcha ; mod admin ; use crate :: util :: string :: Speak ; pub fn get_migrations () -> :: std :: vec :: Vec < :: std :: boxed :: Box < dyn :: sea_orm_migration :: prelude :: MigrationTrait >> { let mut v = :: std :: vec :: Vec :: < :: std :: boxed :: Box < dyn :: sea_orm_migration :: prelude :: MigrationTrait >> :: new () ; v . append (& mut rules :: get_migrations ()) ; v . append (& mut locks :: get_migrations ()) ; v . append (& mut bans :: get_migrations ()) ; v . append (& mut notes :: get_migrations ()) ; v . append (& mut approvals :: get_migrations ()) ; v . append (& mut buttontest :: get_migrations ()) ; v . append (& mut sticker :: get_migrations ()) ; v . append (& mut misc :: get_migrations ()) ; v . append (& mut filters :: get_migrations ()) ; v . append (& mut welcome :: get_migrations ()) ; v . append (& mut blocklists :: get_migrations ()) ; v . append (& mut language :: get_migrations ()) ; v . append (& mut reports :: get_migrations ()) ; v . append (& mut warns :: get_migrations ()) ; v . append (& mut captcha :: get_migrations ()) ; v . append (& mut admin :: get_migrations ()) ; v } pub fn get_metadata () -> :: std :: vec :: Vec < crate :: metadata :: Metadata > { vec ! [(* rules :: METADATA) . clone () , (* locks :: METADATA) . clone () , (* bans :: METADATA) . clone () , (* notes :: METADATA) . clone () , (* approvals :: METADATA) . clone () , (* buttontest :: METADATA) . clone () , (* sticker :: METADATA) . clone () , (* misc :: METADATA) . clone () , (* filters :: METADATA) . clone () , (* welcome :: METADATA) . clone () , (* blocklists :: METADATA) . clone () , (* language :: METADATA) . clone () , (* reports :: METADATA) . clone () , (* warns :: METADATA) . clone () , (* captcha :: METADATA) . clone () , (* admin :: METADATA) . clone () , crate :: metadata :: Metadata { name : "formatting" . to_owned () , description : crate :: metadata :: markdownify (std :: include_str ! ("formatting.mud")) , commands : :: std :: collections :: HashMap :: new () , sections : { let mut v = :: std :: collections :: HashMap :: new () ; v . insert ("Form Filling" . to_owned () , crate :: metadata :: markdownify (std :: include_str ! ("formatting/Form Filling.mud"))) ; v . insert ("Murkdown Formatting" . to_owned () , crate :: metadata :: markdownify (std :: include_str ! ("formatting/Murkdown Formatting.mud"))) ; v } }] } pub async fn process_updates (update : :: botapi :: gen_types :: UpdateExt , helps : :: std :: sync :: Arc < crate :: tg :: client :: MetadataCollection >) -> crate :: util :: error :: Result < () > { match crate :: tg :: command :: StaticContext :: get_context (update) . await . map (| v | v . yoke ()) { Ok (cmd) => { if let Err (err) = cmd . handle_pending_action_update () . await { log :: error ! ("failed to handle pending action: {}" , err) ; err . record_stats () ; } let help = if let Some (& crate :: tg :: command :: Cmd { cmd , ref args , message , lang , .. }) = cmd . cmd () { match cmd { "help" => crate :: tg :: client :: show_help (message , helps , args . args . first () . map (| a | a . get_text ())) . await , "start" => match args . args . first () . map (| a | a . get_text ()) { Some (v) => { if let (Some ("help") , Some (s)) = (v . get (0 .. 4) , v . get (4 ..)) { let s = if s . len () > 0 { Some (s) } else { None } ; crate :: tg :: client :: show_help (message , helps , s) . await ? ; Ok (true) } else { Ok (false) } } None => { message . reply (macros :: lang_fmt ! (lang , "startcmd")) . await ? ; Ok (true) } } , _ => Ok (false) , } } else { Ok (false) } ; match help { Ok (false) => { if let Err (err) = rules :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , rules :: METADATA . name , err) ; } } } if let Err (err) = locks :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , locks :: METADATA . name , err) ; } } } if let Err (err) = bans :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , bans :: METADATA . name , err) ; } } } if let Err (err) = notes :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , notes :: METADATA . name , err) ; } } } if let Err (err) = approvals :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , approvals :: METADATA . name , err) ; } } } if let Err (err) = buttontest :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , buttontest :: METADATA . name , err) ; } } } if let Err (err) = sticker :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , sticker :: METADATA . name , err) ; } } } if let Err (err) = misc :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , misc :: METADATA . name , err) ; } } } if let Err (err) = filters :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , filters :: METADATA . name , err) ; } } } if let Err (err) = welcome :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , welcome :: METADATA . name , err) ; } } } if let Err (err) = blocklists :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , blocklists :: METADATA . name , err) ; } } } if let Err (err) = language :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , language :: METADATA . name , err) ; } } } if let Err (err) = reports :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , reports :: METADATA . name , err) ; } } } if let Err (err) = warns :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , warns :: METADATA . name , err) ; } } } if let Err (err) = captcha :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , captcha :: METADATA . name , err) ; } } } if let Err (err) = admin :: handle_update (& cmd) . await { err . record_stats () ; match err . get_message () . await { Err (err) => { log :: error ! ("failed to send error message: {}, what the FLOOP" , err) ; err . record_stats () ; } Ok (v) => if ! v { if let Some (chat) = cmd . chat () { if let Err (err) = chat . speak (err . to_string ()) . await { log :: error ! ("triple fault! {}" , err) ; } } log :: error ! ("handle_update {} error: {}" , admin :: METADATA . name , err) ; } } } } Ok (true) => () , Err (err) => log :: error ! ("failed help {}" , err) } } Err (err) => err . record_stats () , } Ok (()) }